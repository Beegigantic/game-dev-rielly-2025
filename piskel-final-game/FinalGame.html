<html>
<head>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #222;
    }

    /* visible viewport */
    #game {
        position: relative;
        width: 1280px;
        height: 720px;
        margin: 24px auto;
        overflow: hidden;
        background: #222;
        border: 4px solid #111;
    }

    /* the larger world the camera will move around inside */
    #world {
        position: absolute;
        left: 0;
        top: 0;
        width: 4000px;
        height: 1000px;
        will-change: transform;
    }

    #player {
        position: absolute;
        width: 128px;
        height: 128px;
        left: 100px;
        top: 0;
        background-size: cover;
        transform-origin: center;
    }

    #platform {
        position: absolute;
        bottom: 100px;
        left: 0;
        width: 100%;
        height: 40px;
        background: #555;
    }

    /* simple wall block the player can stick to when holding Z */
    .wall {
        position: absolute;
        width: 64px;
        height: 480px;
        background: #774;
        bottom: 80px; /* sits slightly above the ground */
        left: 800px;
    }

    .particle {
        position: absolute;
        width: 24px;
        height: 24px;
        background-image: url("particles.gif");
        background-size: cover;
        pointer-events: none;
        opacity: 1;
    }

    /* menu / title styles */
    #menu {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.6);
        z-index: 999;
        color: #fff;
        font-family: system-ui, Arial, sans-serif;
    }

    .menu-card {
        background: linear-gradient(180deg,#111,#222);
        padding: 28px;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 6px 30px rgba(0,0,0,0.6);
        min-width: 420px;
    }

    .title { font-size: 48px; letter-spacing: 2px; margin-bottom: 8px; }
    .subtitle { font-size: 14px; color: #bbb; margin-bottom: 18px; }
    .level-row { display: flex; gap: 10px; justify-content: center; margin-bottom: 12px; }
    .menu-button { background:#2b6; border:none; padding:10px 16px; border-radius:8px; cursor:pointer; font-weight:700; }
    .menu-button.alt { background:#58a; }
    .menu-note { margin-top:8px; color:#ccc; font-size:12px }
</style>
</head>
<body>

<div id="game">
    <div id="world">
        <div id="player"></div>
        <div id="platform"></div>
        <div class="wall" id="wall1"></div>
        <!-- add more walls as needed by duplicating the .wall element and changing left/top -->
    </div>
</div>

<!-- Title / Level select menu -->
<div id="menu">
    <div class="menu-card">
        <div class="title">EVEREST</div>
        <div class="subtitle">Choose a level</div>
        <div class="level-row">
            <button class="menu-button" onclick="startLevel(1)">Level 1</button>
            <button class="menu-button" onclick="startLevel(2)">Level 2</button>
            <button class="menu-button" onclick="startLevel(3)">Level 3</button>
        </div>
        <div class="menu-note">Each level has a taller wall — climb carefully.</div>
    </div>
</div>

<script>
const game = document.getElementById("game");
const world = document.getElementById("world");
const player = document.getElementById("player");
const platform = document.getElementById("platform");
const walls = Array.from(document.querySelectorAll('.wall'));

// world dimensions must match the CSS above
const worldWidth = 4000;
const worldHeight = 1000;

// Sprite filenames (easy to change in one place)
const SPRITES = {
    standing: 'standing.gif',
    running: 'running.gif',
    jumping: 'jumping.gif',
    crouching: 'crouching.gif',
    jump_run: 'jump_run.gif',
    wallGrab: 'crouching.gif', // change to your wall-grab image
    dash: 'dash.gif'       // dash image (pointed to the right); will flip when dashing left
};

let x = 100; // player position in world coordinates
let y = 0;
let prevX = x;
let prevY = y;
let velocityY = 0;
let onGround = false;
let facing = 1;
let wasMoving = false;
let wasJumpPressed = false;
let wasStanding = false;

// dash/wall states
let isWallSticking = false;
let wallStickSide = null; // 'left' or 'right'
let wasDashPressed = false;
let isDashing = false;
let dashFramesLeft = 0;
let dashCooldownLeft = 0;
let dashVelX = 0;
let dashVelY = 0;
// wall-jump smoothing
let wallJumpVelX = 0;
let wallJumpFramesLeft = 0;

// one-dash-per-touch-ground
let canDash = true;
// prevent immediate re-stick after wall-jump so player is pushed away naturally
const STICK_COOLDOWN_FRAMES = 18;
let stickCooldown = 0;

const gravity = 0.6;
const speed = 5;
const jumpPower = -12;

// dash tuning (frames)
const DASH_FRAMES = 18; // longer so easing-out lasts longer
const DASH_COOLDOWN_FRAMES = 36; // cooldown after a dash
const DASH_SPEED = 36; // pixels per frame during dash (initially faster)

// wall/jump/slide tuning
const WALL_JUMP_HORZ = 64; // horizontal push when doing a wall-jump while stuck
const WALL_JUMP_HORZ_SLIDE = 120; // stronger horizontal push when jumping from a slide
const WALL_JUMP_VERT = -12; // vertical velocity of wall-jump (same as jumpPower by default)
const SLIDE_CAP = 0.5; // max downward speed while sliding (way slower than freefall)
const SLIDE_PARTICLE_INTERVAL = 10; // frames between slide particles
let slideParticleTimer = 0;

const WALL_JUMP_FRAMES = 16; // how many frames to apply wall-jump horizontal velocity (smoother)

// camera smoothing so abrupt movements (like wall-jump) don't instantly move the viewport
let camX = 0, camY = 0;
const CAM_LERP = 0.16; // normal camera follow lerp (0..1)
const CAM_LERP_SLOW = 0.06; // slower follow used briefly after wall-jump to reduce camera snap
let camHoldFrames = 0; // frames to use slow lerp

const keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

function spawnParticles() {
    for (let i = 0; i < 5; i++) {
        const p = document.createElement("div");
        p.className = "particle";
        // position relative to world
        p.style.left = (x + 52 + Math.random() * 20) + "px";
        p.style.top = (y + 128) + "px";
        world.appendChild(p);

        let life = 30;
        let vy = Math.random() * -1.5;
        let vx = (Math.random() - 0.5) * 2;

        function animate() {
            life--;
            p.style.top = (p.offsetTop + vy) + "px";
            p.style.left = (p.offsetLeft + vx) + "px";
            p.style.opacity = life / 30;
            if (life > 0) requestAnimationFrame(animate);
            else p.remove();
        }
        animate();
    }
}

function spawnDashTrail() {
    // spawn a small burst of particles behind the player in the opposite direction of dash
    const count = 3;
    for (let i = 0; i < count; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        // position behind the player relative to dash direction
        const len = Math.hypot(dashVelX, dashVelY) || 1;
        const nx = dashVelX / len;
        const ny = dashVelY / len;
        // place slightly behind center
        p.style.left = (x + 64 - nx * (12 + Math.random() * 8) + (Math.random() - 0.5) * 8) + 'px';
        p.style.top = (y + 64 - ny * (12 + Math.random() * 8) + (Math.random() - 0.5) * 8) + 'px';
        p.style.width = '16px'; p.style.height = '16px';
        world.appendChild(p);
        let life = 20 + Math.floor(Math.random() * 10);
        let vx = -nx * (2 + Math.random() * 2) + (Math.random() - 0.5) * 1.2;
        let vy = -ny * (2 + Math.random() * 2) + (Math.random() - 0.5) * 1.2;
        function animate() {
            life--;
            p.style.top = (p.offsetTop + vy) + 'px';
            p.style.left = (p.offsetLeft + vx) + 'px';
            p.style.opacity = Math.max(0, life / 30);
            if (life > 0) requestAnimationFrame(animate);
            else p.remove();
        }
        animate();
    }
}

// Start a selected level: configure wall height and start the game loop
let selectedLevel = 1;
// guard so we only start the game loop once (prevents multiple concurrent loops)
let gameStarted = false;
function startLevel(level) {
    selectedLevel = level;
    const wall = document.getElementById('wall1');
    // choose wall height per level (px)
    const heights = {1: 240, 2: 400, 3: 640};
    const h = heights[level] || 240;
    wall.style.height = h + 'px';
    // place wall somewhere in the world (keep left at 800)
    wall.style.left = (800 + (level-1)*160) + 'px';

    // reset player and state for a fresh start
    x = 100 + (level-1)*40;
    y = 0;
    velocityY = 0;
    isDashing = false; dashFramesLeft = 0; dashVelX = 0; dashVelY = 0;
    wallJumpVelX = 0; wallJumpFramesLeft = 0;
    stickCooldown = 0;
    canDash = true;

    // hide menu and start game loop
    document.getElementById('menu').style.display = 'none';
    // start the loop only once — subsequent level selects should not spawn extra loops
    if (!gameStarted) { gameStarted = true; update(); }
}

function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function update() {
    // frame start: preserve previous position for collision-side checks
    prevX = x;
    prevY = y;

    // update cooldowns
    if (dashCooldownLeft > 0) dashCooldownLeft--;
    if (stickCooldown > 0) stickCooldown--;

    let moving = false;
    let crouching = keys["ArrowDown"] && onGround;
    let wasOnGround = onGround;

    // ...existing code...

    // DASH activation (edge detect)
    if (keys['KeyX'] && !wasDashPressed && dashCooldownLeft === 0 && dashFramesLeft === 0 && canDash) {
        // direction from arrow keys
        let dirX = (keys['ArrowRight'] ? 1 : 0) - (keys['ArrowLeft'] ? 1 : 0);
        let dirY = (keys['ArrowDown'] ? 1 : 0) - (keys['ArrowUp'] ? 1 : 0);
        if (dirX === 0 && dirY === 0) dirX = facing; // default to facing direction
        const len = Math.hypot(dirX, dirY) || 1;
        dirX /= len; dirY /= len;

        dashVelX = dirX * DASH_SPEED;
        dashVelY = dirY * DASH_SPEED;
        dashFramesLeft = DASH_FRAMES;
        dashCooldownLeft = DASH_COOLDOWN_FRAMES;
        isDashing = true;
        // reset vertical velocity while dashing
        velocityY = 0;
        // consume dash until we touch ground again
        canDash = false;
    }

    // Movement only applies when not dashing and not wall-sticking
    if (!isDashing && !isWallSticking) {
        if (!crouching) {
            if (keys["ArrowLeft"]) {
                if (!wasMoving && onGround) spawnParticles();
                x -= speed;
                moving = true;
                facing = -1;
            }
            if (keys["ArrowRight"]) {
                if (!wasMoving && onGround) spawnParticles();
                x += speed;
                moving = true;
                facing = 1;
            }
        }

        // Note: normal ground jump handled after wall checks so wall-jump can also trigger

        velocityY += gravity;
        y += velocityY;
    } else if (isDashing && dashFramesLeft > 0) {
        // perform dash movement (frames-based) with ease-out so it slows toward the end
        // multiplier ranges from ~1 down to small >0; square it for stronger easing
        const factor = dashFramesLeft / DASH_FRAMES; // 1 -> 0
        const ease = factor * factor; // quadratic ease-out curve
        x += dashVelX * ease;
        y += dashVelY * ease;
        // spawn dash trail particles while dashing
        spawnDashTrail();
        dashFramesLeft--;
        if (dashFramesLeft === 0) {
            isDashing = false;
            // after dash, resume gravity; keep a small residual velocity if desired
            velocityY = 0;
        }
    }

    // platform collision (same as before)
    const platformTop = platform.offsetTop;
    if (y + 128 >= platformTop) {
        y = platformTop - 128;
        velocityY = 0;
        onGround = true;
    } else {
        onGround = false;
    }

    if (!wasOnGround && onGround) {
        spawnParticles();
        // reset dash availability when touching the ground
        canDash = true;
    }

    // Resolve wall collisions (make walls solid) and compute side-touching for wall-stick
    let collidedDuringDash = false;
    const pw = 128, ph = 128;
    for (const w of walls) {
        const wl = w.offsetLeft, wt = w.offsetTop, ww = w.offsetWidth, wh = w.offsetHeight;
        if (rectsOverlap(x, y, pw, ph, wl, wt, ww, wh)) {
            // compute overlap amounts
            const overlapX = Math.min(x + pw, wl + ww) - Math.max(x, wl);
            const overlapY = Math.min(y + ph, wt + wh) - Math.max(y, wt);
            if (overlapX < overlapY) {
                // resolve horizontally
                if (x + pw / 2 < wl + ww / 2) {
                    // player is on the left side -> push left
                    x -= overlapX;
                } else {
                    // player on the right side -> push right
                    x += overlapX;
                }
            } else {
                // resolve vertically
                if (y + ph / 2 < wt + wh / 2) {
                    // player above the wall -> push up
                    y -= overlapY;
                    velocityY = 0;
                    onGround = true; // treat the top of a wall as ground for now
                } else {
                    // player below the wall -> push down
                    y += overlapY;
                    velocityY = 0;
                }
            }
            // if we were dashing and collided with a wall, stop the dash early
            if (isDashing) collidedDuringDash = true;
        }
    }

    if (collidedDuringDash) {
        isDashing = false;
        dashFramesLeft = 0;
        // keep dash cooldown as-is
    }

    // Wall sticking: only if holding Z, not dashing, not on ground, and touching the vertical side
    let touchingWall = false;
    wallStickSide = null;
    if (!isDashing && keys['KeyZ'] && !onGround) {
        for (const w of walls) {
            const wl = w.offsetLeft, wt = w.offsetTop, ww = w.offsetWidth, wh = w.offsetHeight;
            const wr = wl + ww, wb = wt + wh;
            // vertical overlap required
            if (y + ph > wt && y < wb) {
                // check if player is adjacent to left or right side (small tolerance)
                const tol = 4;
                // only allow sticking if stickCooldown expired
                if (stickCooldown === 0 && Math.abs((x + pw) - wl) <= tol) {
                    touchingWall = true;
                    wallStickSide = 'left';
                    x = wl - pw; // snap flush to wall side
                    break;
                }
                if (stickCooldown === 0 && Math.abs(x - wr) <= tol) {
                    touchingWall = true;
                    wallStickSide = 'right';
                    x = wr; // snap flush
                    break;
                }
            }
        }
    }

    if (touchingWall) {
        isWallSticking = true;
        // cancel vertical velocity so player holds to the wall
        velocityY = 0;
    } else {
        // release stick when Z released or not adjacent
        if (!keys['KeyZ']) isWallSticking = false;
    }

    // detect being near a wall (but not stuck) so we can slide and allow wall-jump even if not explicitly sticking
    let nearWall = false;
    let nearWallSide = null;
    const NEAR_TOL = 14; // pixels
    if (!isWallSticking && !onGround) {
        for (const w of walls) {
            const wl = w.offsetLeft, wt = w.offsetTop, ww = w.offsetWidth, wh = w.offsetHeight;
            const wr = wl + ww, wb = wt + wh;
            if (y + ph > wt && y < wb) {
                // require pushing toward the wall to be considered 'near' for sliding
                if (Math.abs((x + pw) - wl) <= NEAR_TOL && keys['ArrowRight']) {
                    nearWall = true; nearWallSide = 'left'; break;
                }
                if (Math.abs(x - wr) <= NEAR_TOL && keys['ArrowLeft']) {
                    nearWall = true; nearWallSide = 'right'; break;
                }
            }
        }
    }

    // sliding effect when next to a wall but not sticking
    if (nearWall && !isWallSticking && !onGround) {
        // cap downward speed so sliding is slower than freefall
        if (velocityY > SLIDE_CAP) velocityY = SLIDE_CAP;
        // spawn particles occasionally while sliding
        slideParticleTimer++;
        if (slideParticleTimer >= SLIDE_PARTICLE_INTERVAL) {
            slideParticleTimer = 0;
            // small particle burst
            const p = document.createElement('div');
            p.className = 'particle';
            p.style.left = (x + 52) + 'px';
            p.style.top = (y + 120) + 'px';
            world.appendChild(p);
            let life = 20; let vy = 1.2; let vx = (Math.random() - 0.5) * 1.2;
            function anim() { life--; p.style.top = (p.offsetTop + vy) + 'px'; p.style.left = (p.offsetLeft + vx) + 'px'; p.style.opacity = life/20; if (life>0) requestAnimationFrame(anim); else p.remove(); }
            anim();
        }
    } else {
        slideParticleTimer = 0;
    }

    // Handle jumping after wall checks so wall-jump and near-wall jump work
    if (keys["Space"] && !wasJumpPressed) {
        if (onGround) {
            spawnParticles();
            velocityY = jumpPower;
            onGround = false;
        } else if (isWallSticking || nearWall) {
            // wall-jump: push away from the wall and apply vertical jump
            spawnParticles();
            velocityY = WALL_JUMP_VERT;
            // horizontal push away from wall (stronger when jumping from a slide)
            if (isWallSticking) {
                wallJumpVelX = (wallStickSide === 'left' ? -1 : 1) * (WALL_JUMP_HORZ / WALL_JUMP_FRAMES);
                wallJumpFramesLeft = WALL_JUMP_FRAMES;
                facing = (wallStickSide === 'left') ? -1 : 1;
            } else if (nearWall) {
                wallJumpVelX = (nearWallSide === 'left' ? -1 : 1) * (WALL_JUMP_HORZ_SLIDE / WALL_JUMP_FRAMES);
                wallJumpFramesLeft = WALL_JUMP_FRAMES;
                facing = (nearWallSide === 'left') ? -1 : 1;
            }
            // prevent immediate re-stick for a short time so the player is launched away naturally
            stickCooldown = STICK_COOLDOWN_FRAMES;
            // after wall-jump, ensure player is not stuck; require re-hold Z and correct side to stick again
            isWallSticking = false;
            // reduce camera snap by holding slow lerp for a few frames
            camHoldFrames = 18;
        }
    }

    // apply smooth horizontal motion from a wall-jump over several frames
    if (wallJumpFramesLeft > 0 && !isDashing) {
        x += wallJumpVelX;
        wallJumpFramesLeft--;
        // optional decay
        wallJumpVelX *= 0.9;
    }

    // choose sprite: wall grab and dash sprites override others while active
    let sprite = SPRITES.standing;
    if (isWallSticking) {
        sprite = SPRITES.wallGrab;
    } else if (isDashing) {
        sprite = SPRITES.dash;
    } else if (crouching) {
        sprite = SPRITES.crouching;
    } else if (!onGround && moving) {
        sprite = SPRITES.jump_run;
    } else if (!onGround) {
        sprite = SPRITES.jumping;
    } else if (moving) {
        sprite = SPRITES.running;
    }

    // clamp to world bounds
    x = clamp(x, 0, worldWidth - 128);
    y = clamp(y, 0, worldHeight - 128);

    // set player position in world coords
    player.style.left = x + "px";
    player.style.top = y + "px";
    // If dashing, rotate the dash sprite to point in dash direction (dash.gif faces right by default).
    if (isDashing && (Math.abs(dashVelX) > 0.001 || Math.abs(dashVelY) > 0.001)) {
        const angle = Math.atan2(dashVelY, dashVelX) * 180 / Math.PI; // degrees
        player.style.transform = `rotate(${angle}deg)`;
    } else {
        // non-dash: preserve simple horizontal flip based on facing
        player.style.transform = `scaleX(${facing})`;
    }
    player.style.backgroundImage = `url("${sprite}")`;

    // camera: smooth follow to reduce snapping on wall-jump
    const gameWidth = game.clientWidth;
    const gameHeight = game.clientHeight;
    const targetCamX = clamp(x + 64 - gameWidth / 2, 0, worldWidth - gameWidth);
    const targetCamY = clamp(y + 64 - gameHeight / 2, 0, worldHeight - gameHeight);
    const lerp = camHoldFrames > 0 ? CAM_LERP_SLOW : CAM_LERP;
    camX += (targetCamX - camX) * lerp;
    camY += (targetCamY - camY) * lerp;
    if (camHoldFrames > 0) camHoldFrames--;
    world.style.transform = `translate(${-Math.round(camX)}px, ${-Math.round(camY)}px)`;

    // recompute current crouching/standing now that physics and collisions are applied
    const crouchingNow = keys["ArrowDown"] && onGround;
    const standing = onGround && !moving && !crouchingNow;
    // if we just started standing (landed and stopped), recharge dash
    if (standing && !wasStanding) {
        canDash = true;
    }

    wasStanding = standing;
    wasMoving = moving;
    wasJumpPressed = keys["Space"];
    wasDashPressed = keys['KeyX'];

    requestAnimationFrame(update);
}
</script>

</body>
</html>
